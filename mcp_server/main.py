# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T15:56:47+00:00



import argparse
import json
import os
import logging
from datetime import date as date_aliased
from datetime import datetime
from pathlib import Path
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import (
    BaseSecurity,
    HTTPBearer,
    UnsuportedSecurityStub,
)
from fastapi import Query, UploadFile, Request
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import JSONResponse
logger = logging.getLogger(__name__)


from models import (
    ActorType,
    AttachmentsAttachmentGidDeleteResponse,
    AttachmentsAttachmentGidGetResponse,
    AttachmentsGetResponse,
    AttachmentsPostResponse,
    BatchPostRequest,
    BatchPostResponse,
    CustomFieldsCustomFieldGidDeleteResponse,
    CustomFieldsCustomFieldGidEnumOptionsInsertPostRequest,
    CustomFieldsCustomFieldGidEnumOptionsInsertPostResponse,
    CustomFieldsCustomFieldGidEnumOptionsPostRequest,
    CustomFieldsCustomFieldGidEnumOptionsPostResponse,
    CustomFieldsCustomFieldGidGetResponse,
    CustomFieldsCustomFieldGidPutRequest,
    CustomFieldsCustomFieldGidPutResponse,
    CustomFieldsPostRequest,
    CustomFieldsPostResponse,
    EnumOptionsEnumOptionGidPutRequest,
    EnumOptionsEnumOptionGidPutResponse,
    ErrorResponse,
    EventsGetResponse,
    GoalRelationshipsGetResponse,
    GoalRelationshipsGoalRelationshipGidGetResponse,
    GoalRelationshipsGoalRelationshipGidPutRequest,
    GoalRelationshipsGoalRelationshipGidPutResponse,
    GoalsGetResponse,
    GoalsGoalGidAddFollowersPostRequest,
    GoalsGoalGidAddFollowersPostResponse,
    GoalsGoalGidAddSupportingRelationshipPostRequest,
    GoalsGoalGidAddSupportingRelationshipPostResponse,
    GoalsGoalGidDeleteResponse,
    GoalsGoalGidGetResponse,
    GoalsGoalGidParentGoalsGetResponse,
    GoalsGoalGidPutRequest,
    GoalsGoalGidPutResponse,
    GoalsGoalGidRemoveFollowersPostRequest,
    GoalsGoalGidRemoveFollowersPostResponse,
    GoalsGoalGidRemoveSupportingRelationshipPostRequest,
    GoalsGoalGidRemoveSupportingRelationshipPostResponse,
    GoalsGoalGidSetMetricCurrentValuePostRequest,
    GoalsGoalGidSetMetricCurrentValuePostResponse,
    GoalsGoalGidSetMetricPostRequest,
    GoalsGoalGidSetMetricPostResponse,
    GoalsPostRequest,
    GoalsPostResponse,
    JobsJobGidGetResponse,
    OptFields,
    OrganizationExportsOrganizationExportGidGetResponse,
    OrganizationExportsPostRequest,
    OrganizationExportsPostResponse,
    PortfolioMembershipsGetResponse,
    PortfolioMembershipsPortfolioMembershipGidGetResponse,
    PortfoliosGetResponse,
    PortfoliosPortfolioGidAddCustomFieldSettingPostRequest,
    PortfoliosPortfolioGidAddCustomFieldSettingPostResponse,
    PortfoliosPortfolioGidAddItemPostRequest,
    PortfoliosPortfolioGidAddItemPostResponse,
    PortfoliosPortfolioGidAddMembersPostRequest,
    PortfoliosPortfolioGidAddMembersPostResponse,
    PortfoliosPortfolioGidCustomFieldSettingsGetResponse,
    PortfoliosPortfolioGidDeleteResponse,
    PortfoliosPortfolioGidGetResponse,
    PortfoliosPortfolioGidItemsGetResponse,
    PortfoliosPortfolioGidPortfolioMembershipsGetResponse,
    PortfoliosPortfolioGidPutRequest,
    PortfoliosPortfolioGidPutResponse,
    PortfoliosPortfolioGidRemoveCustomFieldSettingPostRequest,
    PortfoliosPortfolioGidRemoveCustomFieldSettingPostResponse,
    PortfoliosPortfolioGidRemoveItemPostRequest,
    PortfoliosPortfolioGidRemoveItemPostResponse,
    PortfoliosPortfolioGidRemoveMembersPostRequest,
    PortfoliosPortfolioGidRemoveMembersPostResponse,
    PortfoliosPostRequest,
    PortfoliosPostResponse,
    ProjectBriefsProjectBriefGidDeleteResponse,
    ProjectBriefsProjectBriefGidGetResponse,
    ProjectBriefsProjectBriefGidPutRequest,
    ProjectBriefsProjectBriefGidPutResponse,
    ProjectMembershipsProjectMembershipGidGetResponse,
    ProjectsGetResponse,
    ProjectsPostRequest,
    ProjectsPostResponse,
    ProjectsProjectGidAddCustomFieldSettingPostRequest,
    ProjectsProjectGidAddCustomFieldSettingPostResponse,
    ProjectsProjectGidAddFollowersPostRequest,
    ProjectsProjectGidAddFollowersPostResponse,
    ProjectsProjectGidAddMembersPostRequest,
    ProjectsProjectGidAddMembersPostResponse,
    ProjectsProjectGidCustomFieldSettingsGetResponse,
    ProjectsProjectGidDeleteResponse,
    ProjectsProjectGidDuplicatePostRequest,
    ProjectsProjectGidDuplicatePostResponse,
    ProjectsProjectGidGetResponse,
    ProjectsProjectGidProjectBriefsPostRequest,
    ProjectsProjectGidProjectBriefsPostResponse,
    ProjectsProjectGidProjectMembershipsGetResponse,
    ProjectsProjectGidProjectStatusesGetResponse,
    ProjectsProjectGidProjectStatusesPostRequest,
    ProjectsProjectGidProjectStatusesPostResponse,
    ProjectsProjectGidPutRequest,
    ProjectsProjectGidPutResponse,
    ProjectsProjectGidRemoveCustomFieldSettingPostRequest,
    ProjectsProjectGidRemoveCustomFieldSettingPostResponse,
    ProjectsProjectGidRemoveFollowersPostRequest,
    ProjectsProjectGidRemoveFollowersPostResponse,
    ProjectsProjectGidRemoveMembersPostRequest,
    ProjectsProjectGidRemoveMembersPostResponse,
    ProjectsProjectGidSaveAsTemplatePostRequest,
    ProjectsProjectGidSaveAsTemplatePostResponse,
    ProjectsProjectGidSectionsGetResponse,
    ProjectsProjectGidSectionsInsertPostRequest,
    ProjectsProjectGidSectionsInsertPostResponse,
    ProjectsProjectGidSectionsPostRequest,
    ProjectsProjectGidSectionsPostResponse,
    ProjectsProjectGidTaskCountsGetResponse,
    ProjectsProjectGidTasksGetResponse,
    ProjectStatusesProjectStatusGidDeleteResponse,
    ProjectStatusesProjectStatusGidGetResponse,
    ProjectTemplatesGetResponse,
    ProjectTemplatesProjectTemplateGidGetResponse,
    ProjectTemplatesProjectTemplateGidInstantiateProjectPostRequest,
    ProjectTemplatesProjectTemplateGidInstantiateProjectPostResponse,
    ResourceSubtype6,
    ResourceType,
    ResourceType2,
    SectionsSectionGidAddTaskPostRequest,
    SectionsSectionGidAddTaskPostResponse,
    SectionsSectionGidDeleteResponse,
    SectionsSectionGidGetResponse,
    SectionsSectionGidPutRequest,
    SectionsSectionGidPutResponse,
    SectionsSectionGidTasksGetResponse,
    SortBy,
    StatusUpdatesGetResponse,
    StatusUpdatesPostRequest,
    StatusUpdatesPostResponse,
    StatusUpdatesStatusGidDeleteResponse,
    StatusUpdatesStatusGidGetResponse,
    StoriesStoryGidDeleteResponse,
    StoriesStoryGidGetResponse,
    StoriesStoryGidPutRequest,
    StoriesStoryGidPutResponse,
    TagsGetResponse,
    TagsPostRequest,
    TagsPostResponse,
    TagsTagGidDeleteResponse,
    TagsTagGidGetResponse,
    TagsTagGidPutResponse,
    TagsTagGidTasksGetResponse,
    TasksGetResponse,
    TasksPostRequest,
    TasksPostResponse,
    TasksTaskGidAddDependenciesPostRequest,
    TasksTaskGidAddDependenciesPostResponse,
    TasksTaskGidAddDependentsPostRequest,
    TasksTaskGidAddDependentsPostResponse,
    TasksTaskGidAddFollowersPostRequest,
    TasksTaskGidAddFollowersPostResponse,
    TasksTaskGidAddProjectPostRequest,
    TasksTaskGidAddProjectPostResponse,
    TasksTaskGidAddTagPostRequest,
    TasksTaskGidAddTagPostResponse,
    TasksTaskGidDeleteResponse,
    TasksTaskGidDependenciesGetResponse,
    TasksTaskGidDependentsGetResponse,
    TasksTaskGidDuplicatePostRequest,
    TasksTaskGidDuplicatePostResponse,
    TasksTaskGidGetResponse,
    TasksTaskGidProjectsGetResponse,
    TasksTaskGidPutRequest,
    TasksTaskGidPutResponse,
    TasksTaskGidRemoveDependenciesPostRequest,
    TasksTaskGidRemoveDependenciesPostResponse,
    TasksTaskGidRemoveDependentsPostRequest,
    TasksTaskGidRemoveDependentsPostResponse,
    TasksTaskGidRemoveFollowersPostRequest,
    TasksTaskGidRemoveFollowersPostResponse,
    TasksTaskGidRemoveProjectPostRequest,
    TasksTaskGidRemoveProjectPostResponse,
    TasksTaskGidRemoveTagPostRequest,
    TasksTaskGidRemoveTagPostResponse,
    TasksTaskGidSetParentPostRequest,
    TasksTaskGidSetParentPostResponse,
    TasksTaskGidStoriesGetResponse,
    TasksTaskGidStoriesPostRequest,
    TasksTaskGidStoriesPostResponse,
    TasksTaskGidSubtasksGetResponse,
    TasksTaskGidSubtasksPostRequest,
    TasksTaskGidSubtasksPostResponse,
    TasksTaskGidTagsGetResponse,
    TeamMembershipsGetResponse,
    TeamMembershipsTeamMembershipGidGetResponse,
    TeamsPostRequest,
    TeamsPostResponse,
    TeamsPutRequest,
    TeamsPutResponse,
    TeamsTeamGidAddUserPostRequest,
    TeamsTeamGidAddUserPostResponse,
    TeamsTeamGidGetResponse,
    TeamsTeamGidProjectsGetResponse,
    TeamsTeamGidProjectsPostRequest,
    TeamsTeamGidProjectsPostResponse,
    TeamsTeamGidProjectTemplatesGetResponse,
    TeamsTeamGidRemoveUserPostRequest,
    TeamsTeamGidRemoveUserPostResponse,
    TeamsTeamGidTeamMembershipsGetResponse,
    TeamsTeamGidUsersGetResponse,
    TimePeriods,
    TimePeriodsGetResponse,
    TimePeriodsTimePeriodGidGetResponse,
    Type2,
    UsersGetResponse,
    UsersUserGidFavoritesGetResponse,
    UsersUserGidGetResponse,
    UsersUserGidTeamMembershipsGetResponse,
    UsersUserGidTeamsGetResponse,
    UsersUserGidUserTaskListGetResponse,
    UsersUserGidWorkspaceMembershipsGetResponse,
    UserTaskListsUserTaskListGidGetResponse,
    UserTaskListsUserTaskListGidTasksGetResponse,
    WebhooksGetResponse,
    WebhooksPostRequest,
    WebhooksPostResponse,
    WebhooksWebhookGidDeleteResponse,
    WebhooksWebhookGidGetResponse,
    WebhooksWebhookGidPutRequest,
    WebhooksWebhookGidPutResponse,
    WorkspaceMembershipsWorkspaceMembershipGidGetResponse,
    WorkspacesGetResponse,
    WorkspacesWorkspaceGidAddUserPostRequest,
    WorkspacesWorkspaceGidAddUserPostResponse,
    WorkspacesWorkspaceGidAuditLogEventsGetResponse,
    WorkspacesWorkspaceGidCustomFieldsGetResponse,
    WorkspacesWorkspaceGidGetResponse,
    WorkspacesWorkspaceGidProjectsGetResponse,
    WorkspacesWorkspaceGidProjectsPostRequest,
    WorkspacesWorkspaceGidProjectsPostResponse,
    WorkspacesWorkspaceGidPutRequest,
    WorkspacesWorkspaceGidPutResponse,
    WorkspacesWorkspaceGidRemoveUserPostRequest,
    WorkspacesWorkspaceGidRemoveUserPostResponse,
    WorkspacesWorkspaceGidTagsGetResponse,
    WorkspacesWorkspaceGidTagsPostRequest,
    WorkspacesWorkspaceGidTagsPostResponse,
    WorkspacesWorkspaceGidTasksSearchGetResponse,
    WorkspacesWorkspaceGidTeamsGetResponse,
    WorkspacesWorkspaceGidTypeaheadGetResponse,
    WorkspacesWorkspaceGidUsersGetResponse,
    WorkspacesWorkspaceGidWorkspaceMembershipsGetResponse,
)

app = MCPProxy(
    contact={'name': 'Asana Support', 'url': 'https://asana.com/support'},
    description='This is the interface for interacting with the [Asana Platform](https://developers.asana.com). Our API reference is generated from our [OpenAPI spec] (https://raw.githubusercontent.com/Asana/developer-docs/master/defs/asana_oas.yaml).',
    license={
        'name': 'Apache 2.0',
        'url': 'https://www.apache.org/licenses/LICENSE-2.0',
    },
    termsOfService='https://asana.com/terms',
    title='Asana',
    version='1.0',
    servers=[{'description': 'Main endpoint.', 'url': 'https://app.asana.com/api/1.0'}],
)

class APIKeyMiddleware(BaseHTTPMiddleware):
    """Require a static API key for all incoming requests."""

    def __init__(
        self,
        app: MCPProxy,
        api_key: str,
        header_name: str = "x-mcp-api-key",
        exempt_paths: Optional[set[str]] | None = None,
    ) -> None:
        super().__init__(app)
        self.api_key = api_key
        self.header_name = header_name.lower()
        self.exempt_paths = exempt_paths or set()

    async def dispatch(self, request: Request, call_next):
        if not self.api_key:
            return await call_next(request)

        path = request.url.path
        if request.method == "OPTIONS" or path in self.exempt_paths:
            return await call_next(request)

        header_value = request.headers.get(self.header_name)
        auth_header = request.headers.get("authorization")

        valid = False
        if header_value and header_value.strip() == self.api_key:
            valid = True
        elif auth_header and auth_header.lower().startswith("bearer "):
            token = auth_header.split(" ", 1)[1].strip()
            if token == self.api_key:
                valid = True

        if not valid:
            return JSONResponse(
                status_code=401,
                content={"detail": "Missing or invalid MCP API key."},
                headers={"WWW-Authenticate": "Bearer"},
            )

        return await call_next(request)



def _wrap_text_content(payload: dict[str, Any]) -> dict[str, list[dict[str, str]]]:
    """Return MCP-compliant text content wrapper."""
    return {"content": [{"type": "text", "text": json.dumps(payload, ensure_ascii=False)}]}


def _resolve_workspace_gid(app: MCPProxy) -> str:
    """Find a workspace gid via env or the first available workspace."""
    cached = os.environ.get("ASANA_WORKSPACE_GID")
    if cached:
        return cached

    workspaces_fn = app.get_function("get_workspaces")
    response = workspaces_fn()
    items = response.get("data") or []
    if not items:
        raise RuntimeError("Unable to determine Asana workspace - set ASANA_WORKSPACE_GID")

    gid = items[0].get("gid")
    if not gid:
        raise RuntimeError("Workspace response missing gid; set ASANA_WORKSPACE_GID explicitly")
    return gid


def _register_tool(func: Callable[..., dict[str, Any]], description: str) -> None:
    """Attach metadata and register a custom tool with the proxy."""
    func._description = description  # type: ignore[attr-defined]
    existing = {f.__name__ for f in app._registered_funcs}
    if func.__name__ not in existing:
        app._registered_funcs.append(func)


def search(query: str) -> dict[str, list[dict[str, str]]]:
    """Search Asana tasks and projects via the typeahead API."""
    query = (query or "").strip()
    if not query:
        return _wrap_text_content({"results": []})

    try:
        workspace_gid = _resolve_workspace_gid(app)
    except Exception as exc:  # pragma: no cover - logging path
        logger.warning("Search aborted: %s", exc)
        return _wrap_text_content({"results": []})

    limit = int(os.environ.get("ASANA_SEARCH_LIMIT", "5"))
    typeahead_fn = app.get_function("typeahead_for_workspace")

    seen: set[str] = set()
    results: list[dict[str, str]] = []
    for resource_type in ("task", "project"):
        try:
            response = typeahead_fn(
                workspace_gid=workspace_gid,
                resource_type=resource_type,
                query=query,
                count=limit,
            )
        except Exception as exc:  # pragma: no cover - network failures
            logger.debug("Typeahead for %s failed: %s", resource_type, exc)
            continue

        for item in response.get("data", []):
            gid = item.get("gid") or item.get("id")
            if not gid:
                continue
            compound_id = f"{resource_type}:{gid}"
            if compound_id in seen:
                continue
            seen.add(compound_id)

            title = item.get("name") or f"{resource_type.title()} {gid}"
            url = item.get("permalink_url")
            if not url:
                if resource_type == "task":
                    url = f"https://app.asana.com/0/{workspace_gid}/{gid}"
                elif resource_type == "project":
                    url = f"https://app.asana.com/0/{gid}/list"
                else:
                    url = f"https://app.asana.com/0/{gid}"

            results.append({
                "id": compound_id,
                "title": title,
                "url": url,
            })

    return _wrap_text_content({"results": results})


def fetch(document_id: str) -> dict[str, list[dict[str, str]]]:
    """Fetch the full record for a task or project."""
    if not document_id:
        raise ValueError("Document identifier is required")

    if ":" in document_id:
        resource_type, gid = document_id.split(":", 1)
    else:
        resource_type, gid = "task", document_id

    resource_type = resource_type.lower().strip()
    gid = gid.strip()
    if not gid:
        raise ValueError("Document identifier missing Asana gid")

    if resource_type == "task":
        fetch_fn = app.get_function("get_task")
        opt_fields = "name,notes,permalink_url,completed,assignee.name,due_on,resource_type,resource_subtype"
        response = fetch_fn(task_gid=gid, opt_fields=opt_fields)
    elif resource_type == "project":
        fetch_fn = app.get_function("get_project")
        opt_fields = "name,notes,permalink_url,color,archived,current_status,resource_type"
        response = fetch_fn(project_gid=gid, opt_fields=opt_fields)
    else:
        raise ValueError(f"Unsupported resource type '{resource_type}'")

    data = response.get("data") or {}
    title = data.get("name") or f"{resource_type.title()} {gid}"
    text_body = data.get("notes") or ""
    url = data.get("permalink_url")
    if not url:
        if resource_type == "task":
            try:
                workspace_gid = _resolve_workspace_gid(app)
            except Exception:
                workspace_gid = "0"
            url = f"https://app.asana.com/0/{workspace_gid}/{gid}"
        else:
            url = f"https://app.asana.com/0/{gid}/list"

    metadata: dict[str, Any] = {
        "resource_type": resource_type,
        "gid": gid,
    }
    if resource_type == "task":
        metadata.update({
            "completed": data.get("completed"),
            "assignee": (data.get("assignee") or {}).get("name") if isinstance(data.get("assignee"), dict) else data.get("assignee"),
            "due_on": data.get("due_on"),
            "resource_subtype": data.get("resource_subtype"),
        })
    else:
        current_status = data.get("current_status") or {}
        metadata.update({
            "color": data.get("color"),
            "archived": data.get("archived"),
            "status": current_status.get("color") if isinstance(current_status, dict) else current_status,
        })

    document = {
        "id": document_id,
        "title": title,
        "text": text_body or title,
        "url": url,
        "metadata": metadata,
    }

    return _wrap_text_content(document)


_register_tool(search, "Search Asana for tasks and projects via typeahead.")
_register_tool(fetch, "Fetch full details for an Asana task or project by id.")
@app.get(
    '/attachments',
    description=""" Returns the compact records for all attachments on the object.

There are three possible `parent` values for this request: `project`, `project_brief`, and `task`. For a project, an attachment refers to a file uploaded to the "Key resources" section in the project Overview. For a project brief, an attachment refers to inline files in the project brief itself. For a task, an attachment refers to a file directly associated to that task. """,
    tags=['attachment_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_attachments_for_object(
    limit: Optional[int] = None,
    offset: Optional[str] = None,
    parent: str = ...,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get attachments from an object
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/attachments',
    description=""" Upload an attachment.

This method uploads an attachment on an object and returns the compact
record for the created attachment object. This is possible by either:

- Providing the URL of the external resource being attached, or
- Downloading the file content first and then uploading it as any other attachment. Note that it is not possible to attach
files from third party services such as Dropbox, Box, Vimeo & Google Drive via the API

The 100MB size limit on attachments in Asana is enforced on this endpoint.

This endpoint expects a multipart/form-data encoded request containing the full contents of the file to be uploaded.

Requests made should follow the HTTP/1.1 specification that line
terminators are of the form `CRLF` or `\r\n` outlined
[here](http://www.w3.org/Protocols/HTTP/1.1/draft-ietf-http-v11-spec-01#Basic-Rules) in order for the server to reliably and properly handle the request. """,
    tags=['attachment_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_attachment_for_object(
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    file: UploadFile = ...,
):
    """
    Upload an attachment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/attachments/{attachment_gid}',
    description=""" Deletes a specific, existing attachment.

Returns an empty data record. """,
    tags=['attachment_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_attachment(
    attachment_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Delete an attachment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/attachments/{attachment_gid}',
    description=""" Get the full record for a single attachment. """,
    tags=['attachment_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_attachment(
    attachment_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get an attachment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/batch',
    description=""" Make multiple requests in parallel to Asana's API. """,
    tags=['batch_request_processing'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_batch_request(
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: BatchPostRequest = ...,
):
    """
    Submit parallel requests
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/custom_fields',
    description=""" Creates a new custom field in a workspace. Every custom field is required
to be created in a specific workspace, and this workspace cannot be
changed once set.

A custom field’s name must be unique within a workspace and not conflict
with names of existing task properties such as `Due Date` or `Assignee`.
A custom field’s type must be one of `text`, `enum`, `multi_enum`, `number`,
`date`, or `people`.

Returns the full record of the newly created custom field. """,
    tags=['custom_field_management', 'workspace_custom_field_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_custom_field(
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
    body: CustomFieldsPostRequest = None,
):
    """
    Create a custom field
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/custom_fields/{custom_field_gid}',
    description=""" A specific, existing custom field can be deleted by making a DELETE request on the URL for that custom field.
Locked custom fields can only be deleted by the user who locked the field.
Returns an empty data record. """,
    tags=['custom_field_management', 'workspace_custom_field_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_custom_field(
    custom_field_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Delete a custom field
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/custom_fields/{custom_field_gid}',
    description=""" Get the complete definition of a custom field’s metadata.

Since custom fields can be defined for one of a number of types, and
these types have different data and behaviors, there are fields that are
relevant to a particular type. For instance, as noted above, enum_options
is only relevant for the enum type and defines the set of choices that
the enum could represent. The examples below show some of these
type-specific custom field definitions. """,
    tags=['custom_field_management', 'workspace_custom_field_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_custom_field(
    custom_field_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get a custom field
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/custom_fields/{custom_field_gid}',
    description=""" A specific, existing custom field can be updated by making a PUT request on the URL for that custom field. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged
When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the custom field.
A custom field’s `type` cannot be updated.
An enum custom field’s `enum_options` cannot be updated with this endpoint. Instead see “Work With Enum Options” for information on how to update `enum_options`.
Locked custom fields can only be updated by the user who locked the field.
Returns the complete updated custom field record. """,
    tags=['custom_field_management', 'workspace_custom_field_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_custom_field(
    custom_field_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: CustomFieldsCustomFieldGidPutRequest = None,
):
    """
    Update a custom field
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/custom_fields/{custom_field_gid}/enum_options',
    description=""" Creates an enum option and adds it to this custom field’s list of enum options. A custom field can have at most 500 enum options (including disabled options). By default new enum options are inserted at the end of a custom field’s list.
Locked custom fields can only have enum options added by the user who locked the field.
Returns the full record of the newly created enum option. """,
    tags=['custom_field_management', 'workspace_custom_field_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_enum_option_for_custom_field(
    custom_field_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
    body: CustomFieldsCustomFieldGidEnumOptionsPostRequest = None,
):
    """
    Create an enum option
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/custom_fields/{custom_field_gid}/enum_options/insert',
    description=""" Moves a particular enum option to be either before or after another specified enum option in the custom field.
Locked custom fields can only be reordered by the user who locked the field. """,
    tags=['custom_field_management', 'workspace_custom_field_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def insert_enum_option_for_custom_field(
    custom_field_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: CustomFieldsCustomFieldGidEnumOptionsInsertPostRequest = None,
):
    """
    Reorder a custom field's enum
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/enum_options/{enum_option_gid}',
    description=""" Updates an existing enum option. Enum custom fields require at least one enabled enum option.
Locked custom fields can only be updated by the user who locked the field.
Returns the full record of the updated enum option. """,
    tags=['custom_field_management', 'workspace_custom_field_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_enum_option(
    enum_option_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: EnumOptionsEnumOptionGidPutRequest = None,
):
    """
    Update an enum option
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/events',
    description=""" Returns the full record for all events that have occurred since the sync
token was created.

A `GET` request to the endpoint `/[path_to_resource]/events` can be made in
lieu of including the resource ID in the data for the request.

Asana limits a single sync token to 100 events. If more than 100 events exist
for a given resource, `has_more: true` will be returned in the response, indicating
that there are more events to pull. 

*Note: The resource returned will be the resource that triggered the
event. This may be different from the one that the events were requested
for. For example, a subscription to a project will contain events for
tasks contained within the project.* """,
    tags=['event_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_events(
    resource: str,
    sync: Optional[str] = None,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get events on a resource
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/goal_relationships',
    description=""" Returns compact goal relationship records. """,
    tags=['goal_and_relationship_management', 'event_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_goal_relationships(
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    supported_goal: str = ...,
    resource_subtype: Optional[str] = None,
):
    """
    Get goal relationships
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/goal_relationships/{goal_relationship_gid}',
    description=""" Returns the complete updated goal relationship record for a single goal relationship. """,
    tags=['goal_and_relationship_management', 'event_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_goal_relationship(
    goal_relationship_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get a goal relationship
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/goal_relationships/{goal_relationship_gid}',
    description=""" An existing goal relationship can be updated by making a PUT request on the URL for
that goal relationship. Only the fields provided in the `data` block will be updated;
any unspecified fields will remain unchanged.

Returns the complete updated goal relationship record. """,
    tags=['goal_and_relationship_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_goal_relationship(
    goal_relationship_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: GoalRelationshipsGoalRelationshipGidPutRequest = ...,
):
    """
    Update a goal relationship
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/goals',
    description=""" Returns compact goal records. """,
    tags=[
        'goal_and_relationship_management',
        'portfolio_management',
        'project_management_functions',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_goals(
    portfolio: Optional[str] = None,
    project: Optional[str] = None,
    is_workspace_level: Optional[bool] = None,
    team: Optional[str] = None,
    workspace: Optional[str] = None,
    time_periods: Optional[TimePeriods] = None,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Get goals
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/goals',
    description=""" Creates a new goal in a workspace or team.

Returns the full record of the newly created goal. """,
    tags=['goal_and_relationship_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_goal(
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
    body: GoalsPostRequest = ...,
):
    """
    Create a goal
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/goals/{goal_gid}',
    description=""" A specific, existing goal can be deleted by making a DELETE request on the URL for that goal.

Returns an empty data record. """,
    tags=['goal_and_relationship_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_goal(
    goal_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Delete a goal
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/goals/{goal_gid}',
    description=""" Returns the complete goal record for a single goal. """,
    tags=['goal_and_relationship_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_goal(
    goal_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get a goal
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/goals/{goal_gid}',
    description=""" An existing goal can be updated by making a PUT request on the URL for
that goal. Only the fields provided in the `data` block will be updated;
any unspecified fields will remain unchanged.

Returns the complete updated goal record. """,
    tags=['goal_and_relationship_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_goal(
    goal_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: GoalsGoalGidPutRequest = ...,
):
    """
    Update a goal
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/goals/{goal_gid}/addFollowers',
    description=""" Adds followers to a goal. Returns the goal the followers were added to.
Each goal can be associated with zero or more followers in the system.
Requests to add/remove followers, if successful, will return the complete updated goal record, described above. """,
    tags=['goal_and_relationship_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def add_followers(
    goal_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: GoalsGoalGidAddFollowersPostRequest = ...,
):
    """
    Add a collaborator to a goal
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/goals/{goal_gid}/addSupportingRelationship',
    description=""" Creates a goal relationship by adding a supporting resource to a given goal.

Returns the newly created goal relationship record. """,
    tags=['goal_and_relationship_management', 'event_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def add_supporting_relationship(
    goal_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: GoalsGoalGidAddSupportingRelationshipPostRequest = ...,
):
    """
    Add a supporting goal relationship
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/goals/{goal_gid}/parentGoals',
    description=""" Returns a compact representation of all of the parent goals of a goal. """,
    tags=['goal_and_relationship_management', 'event_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_parent_goals_for_goal(
    goal_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get parent goals from a goal
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/goals/{goal_gid}/removeFollowers',
    description=""" Removes followers from a goal. Returns the goal the followers were removed from.
Each goal can be associated with zero or more followers in the system.
Requests to add/remove followers, if successful, will return the complete updated goal record, described above. """,
    tags=['goal_and_relationship_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def remove_followers(
    goal_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: GoalsGoalGidRemoveFollowersPostRequest = ...,
):
    """
    Remove a collaborator from a goal
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/goals/{goal_gid}/removeSupportingRelationship',
    description=""" Removes a goal relationship for a given parent goal. """,
    tags=['goal_and_relationship_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def remove_supporting_relationship(
    goal_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: GoalsGoalGidRemoveSupportingRelationshipPostRequest = ...,
):
    """
    Removes a supporting goal relationship
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/goals/{goal_gid}/setMetric',
    description=""" Creates and adds a goal metric to a specified goal. Note that this replaces an existing goal metric if one already exists. """,
    tags=['goal_and_relationship_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_goal_metric(
    goal_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: GoalsGoalGidSetMetricPostRequest = ...,
):
    """
    Create a goal metric
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/goals/{goal_gid}/setMetricCurrentValue',
    description=""" Updates a goal's existing metric's `current_number_value` if one exists,
otherwise responds with a 400 status code.

Returns the complete updated goal metric record. """,
    tags=['goal_and_relationship_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_goal_metric(
    goal_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: GoalsGoalGidSetMetricCurrentValuePostRequest = ...,
):
    """
    Update a goal metric
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/jobs/{job_gid}',
    description=""" Returns the full record for a job. """,
    tags=['job_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_job(
    job_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get a job by id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/organization_exports',
    description=""" This method creates a request to export an Organization. Asana will complete the export at some point after you create the request. """,
    tags=['organization_export_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_organization_export(
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
    body: OrganizationExportsPostRequest = ...,
):
    """
    Create an organization export request
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/organization_exports/{organization_export_gid}',
    description=""" Returns details of a previously-requested Organization export. """,
    tags=['organization_export_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_organization_export(
    organization_export_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get details on an org export request
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/portfolio_memberships',
    description=""" Returns a list of portfolio memberships in compact representation. You must specify `portfolio`, `portfolio` and `user`, or `workspace` and `user`. """,
    tags=['portfolio_management', 'workspace_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_portfolio_memberships(
    portfolio: Optional[str] = None,
    workspace: Optional[str] = None,
    user: Optional[str] = None,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Get multiple portfolio memberships
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/portfolio_memberships/{portfolio_membership_gid}',
    description=""" Returns the complete portfolio record for a single portfolio membership. """,
    tags=['portfolio_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_portfolio_membership(
    portfolio_membership_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get a portfolio membership
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/portfolios',
    description=""" Returns a list of the portfolios in compact representation that are owned by the current API user. """,
    tags=['portfolio_management', 'workspace_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_portfolios(
    limit: Optional[int] = None,
    offset: Optional[str] = None,
    workspace: str = ...,
    owner: str = ...,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get multiple portfolios
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/portfolios',
    description=""" Creates a new portfolio in the given workspace with the supplied name.

Note that portfolios created in the Asana UI may have some state
(like the “Priority” custom field) which is automatically added
to the portfolio when it is created. Portfolios created via our
API will *not* be created with the same initial state to allow
integrations to create their own starting state on a portfolio. """,
    tags=['portfolio_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_portfolio(
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: PortfoliosPostRequest = ...,
):
    """
    Create a portfolio
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/portfolios/{portfolio_gid}',
    description=""" An existing portfolio can be deleted by making a DELETE request on
the URL for that portfolio.

Returns an empty data record. """,
    tags=['portfolio_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_portfolio(
    portfolio_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Delete a portfolio
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/portfolios/{portfolio_gid}',
    description=""" Returns the complete portfolio record for a single portfolio. """,
    tags=['portfolio_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_portfolio(
    portfolio_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get a portfolio
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/portfolios/{portfolio_gid}',
    description=""" An existing portfolio can be updated by making a PUT request on the URL for
that portfolio. Only the fields provided in the `data` block will be updated;
any unspecified fields will remain unchanged.

Returns the complete updated portfolio record. """,
    tags=['portfolio_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_portfolio(
    portfolio_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: PortfoliosPortfolioGidPutRequest = ...,
):
    """
    Update a portfolio
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/portfolios/{portfolio_gid}/addCustomFieldSetting',
    description=""" Custom fields are associated with portfolios by way of custom field settings.  This method creates a setting for the portfolio. """,
    tags=[
        'custom_field_management',
        'portfolio_management',
        'workspace_custom_field_functions',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def add_custom_field_setting_for_portfolio(
    portfolio_gid: str,
    opt_pretty: Optional[bool] = None,
    body: PortfoliosPortfolioGidAddCustomFieldSettingPostRequest = ...,
):
    """
    Add a custom field to a portfolio
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/portfolios/{portfolio_gid}/addItem',
    description=""" Add an item to a portfolio.
Returns an empty data block. """,
    tags=['portfolio_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def add_item_for_portfolio(
    portfolio_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: PortfoliosPortfolioGidAddItemPostRequest = ...,
):
    """
    Add a portfolio item
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/portfolios/{portfolio_gid}/addMembers',
    description=""" Adds the specified list of users as members of the portfolio.
Returns the updated portfolio record. """,
    tags=['portfolio_management', 'user_account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def add_members_for_portfolio(
    portfolio_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: PortfoliosPortfolioGidAddMembersPostRequest = ...,
):
    """
    Add users to a portfolio
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/portfolios/{portfolio_gid}/custom_field_settings',
    description=""" Returns a list of all of the custom fields settings on a portfolio, in compact form. """,
    tags=['custom_field_management', 'portfolio_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_custom_field_settings_for_portfolio(
    portfolio_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Get a portfolio's custom fields
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/portfolios/{portfolio_gid}/items',
    description=""" Get a list of the items in compact form in a portfolio. """,
    tags=['portfolio_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_items_for_portfolio(
    portfolio_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Get portfolio items
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/portfolios/{portfolio_gid}/portfolio_memberships',
    description=""" Returns the compact portfolio membership records for the portfolio. """,
    tags=['portfolio_management', 'workspace_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_portfolio_memberships_for_portfolio(
    portfolio_gid: str,
    user: Optional[str] = None,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Get memberships from a portfolio
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/portfolios/{portfolio_gid}/removeCustomFieldSetting',
    description=""" Removes a custom field setting from a portfolio. """,
    tags=[
        'custom_field_management',
        'portfolio_management',
        'workspace_operations_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def remove_custom_field_setting_for_portfolio(
    portfolio_gid: str,
    opt_pretty: Optional[bool] = None,
    body: PortfoliosPortfolioGidRemoveCustomFieldSettingPostRequest = ...,
):
    """
    Remove a custom field from a portfolio
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/portfolios/{portfolio_gid}/removeItem',
    description=""" Remove an item from a portfolio.
Returns an empty data block. """,
    tags=['portfolio_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def remove_item_for_portfolio(
    portfolio_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: PortfoliosPortfolioGidRemoveItemPostRequest = ...,
):
    """
    Remove a portfolio item
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/portfolios/{portfolio_gid}/removeMembers',
    description=""" Removes the specified list of users from members of the portfolio.
Returns the updated portfolio record. """,
    tags=['portfolio_management', 'user_account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def remove_members_for_portfolio(
    portfolio_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: PortfoliosPortfolioGidRemoveMembersPostRequest = ...,
):
    """
    Remove users from a portfolio
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/project_briefs/{project_brief_gid}',
    description=""" Deletes a specific, existing project brief.

Returns an empty data record. """,
    tags=['project_management_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_project_brief(
    project_brief_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Delete a project brief
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/project_briefs/{project_brief_gid}',
    description=""" Get the full record for a project brief. """,
    tags=['project_management_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_project_brief(
    project_brief_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get a project brief
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/project_briefs/{project_brief_gid}',
    description=""" An existing project brief can be updated by making a PUT request on the URL for
that project brief. Only the fields provided in the `data` block will be updated;
any unspecified fields will remain unchanged.

Returns the complete updated project brief record. """,
    tags=['project_management_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_project_brief(
    project_brief_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: ProjectBriefsProjectBriefGidPutRequest = ...,
):
    """
    Update a project brief
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/project_memberships/{project_membership_gid}',
    description=""" Returns the complete project record for a single project membership. """,
    tags=['project_membership_management', 'project_management_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_project_membership(
    project_membership_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get a project membership
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/project_statuses/{project_status_gid}',
    description=""" *Deprecated: new integrations should prefer the `/status_updates/{status_gid}` route.*

Deletes a specific, existing project status update.

Returns an empty data record. """,
    tags=['status_update_management', 'project_management_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_project_status(
    project_status_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Delete a project status
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/project_statuses/{project_status_gid}',
    description=""" *Deprecated: new integrations should prefer the `/status_updates/{status_gid}` route.*

Returns the complete record for a single status update. """,
    tags=['project_management_functions', 'status_update_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_project_status(
    project_status_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get a project status
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/project_templates',
    description=""" Returns the compact project template records for all project templates in the given team or workspace. """,
    tags=['project_management_functions', 'workspace_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_project_templates(
    workspace: Optional[str] = None,
    team: Optional[str] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get multiple project templates
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/project_templates/{project_template_gid}',
    description=""" Returns the complete project template record for a single project template. """,
    tags=['project_management_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_project_template(
    project_template_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get a project template
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/project_templates/{project_template_gid}/instantiateProject',
    description=""" Creates and returns a job that will asynchronously handle the project instantiation.

To form this request, it is recommended to first make a request to [get a project template](/docs/get-a-project-template). Then, from the response, copy the `gid` from the object in the `requested_dates` array. This `gid` should be used in `requested_dates` to instantiate a project.

_Note: The body of this request will differ if your workspace is an organization. To determine if your workspace is an organization, use the [is_organization](/docs/workspace) parameter._ """,
    tags=['project_management_functions', 'workspace_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def instantiate_project(
    project_template_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: ProjectTemplatesProjectTemplateGidInstantiateProjectPostRequest = None,
):
    """
    Instantiate a project from a project template
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects',
    description=""" Returns the compact project records for some filtered set of projects. Use one or more of the parameters provided to filter the projects returned.
*Note: This endpoint may timeout for large domains. Try filtering by team!* """,
    tags=['project_management_functions', 'workspace_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_projects(
    limit: Optional[int] = None,
    offset: Optional[str] = None,
    workspace: Optional[str] = None,
    team: Optional[str] = None,
    archived: Optional[bool] = None,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get multiple projects
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects',
    description=""" Create a new project in a workspace or team.

Every project is required to be created in a specific workspace or
organization, and this cannot be changed once set. Note that you can use
the `workspace` parameter regardless of whether or not it is an
organization.

If the workspace for your project is an organization, you must also
supply a `team` to share the project with.

Returns the full record of the newly created project. """,
    tags=['project_management_functions', 'workspace_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_project(
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: ProjectsPostRequest = ...,
):
    """
    Create a project
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project_gid}',
    description=""" A specific, existing project can be deleted by making a DELETE request on
the URL for that project.

Returns an empty data record. """,
    tags=['project_management_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_project(
    project_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Delete a project
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project_gid}',
    description=""" Returns the complete project record for a single project. """,
    tags=['project_management_functions', 'workspace_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_project(
    project_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get a project
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/projects/{project_gid}',
    description=""" A specific, existing project can be updated by making a PUT request on
the URL for that project. Only the fields provided in the `data` block
will be updated; any unspecified fields will remain unchanged.

When using this method, it is best to specify only those fields you wish
to change, or else you may overwrite changes made by another user since
you last retrieved the task.

Returns the complete updated project record. """,
    tags=[
        'project_management_functions',
        'project_membership_management',
        'status_update_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_project(
    project_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: ProjectsProjectGidPutRequest = ...,
):
    """
    Update a project
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project_gid}/addCustomFieldSetting',
    description=""" Custom fields are associated with projects by way of custom field settings.  This method creates a setting for the project. """,
    tags=[
        'custom_field_management',
        'project_management_functions',
        'workspace_operations_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def add_custom_field_setting_for_project(
    project_gid: str,
    opt_pretty: Optional[bool] = None,
    body: ProjectsProjectGidAddCustomFieldSettingPostRequest = ...,
):
    """
    Add a custom field to a project
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project_gid}/addFollowers',
    description=""" Adds the specified list of users as followers to the project. Followers are a subset of members who have opted in to receive "tasks added" notifications for a project. Therefore, if the users are not already members of the project, they will also become members as a result of this operation.
Returns the updated project record. """,
    tags=['goal_and_relationship_management', 'project_membership_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def add_followers_for_project(
    project_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: ProjectsProjectGidAddFollowersPostRequest = ...,
):
    """
    Add followers to a project
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project_gid}/addMembers',
    description=""" Adds the specified list of users as members of the project. Note that a user being added as a member may also be added as a *follower* as a result of this operation. This is because the user's default notification settings (i.e., in the "Notifcations" tab of "My Profile Settings") will override this endpoint's default behavior of setting "Tasks added" notifications to `false`.
Returns the updated project record. """,
    tags=[
        'project_membership_management',
        'project_management_functions',
        'user_account_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def add_members_for_project(
    project_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: ProjectsProjectGidAddMembersPostRequest = ...,
):
    """
    Add users to a project
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project_gid}/custom_field_settings',
    description=""" Returns a list of all of the custom fields settings on a project, in compact form. Note that, as in all queries to collections which return compact representation, `opt_fields` can be used to include more data than is returned in the compact representation. See the [getting started guide on input/output options](https://developers.asana.com/docs/#input-output-options) for more information. """,
    tags=['custom_field_management', 'workspace_custom_field_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_custom_field_settings_for_project(
    project_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Get a project's custom fields
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project_gid}/duplicate',
    description=""" Creates and returns a job that will asynchronously handle the duplication. """,
    tags=['project_management_functions', 'workspace_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def duplicate_project(
    project_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: ProjectsProjectGidDuplicatePostRequest = None,
):
    """
    Duplicate a project
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project_gid}/project_briefs',
    description=""" Creates a new project brief.

Returns the full record of the newly created project brief. """,
    tags=['project_management_functions', 'workspace_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_project_brief(
    project_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: ProjectsProjectGidProjectBriefsPostRequest = ...,
):
    """
    Create a project brief
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project_gid}/project_memberships',
    description=""" Returns the compact project membership records for the project. """,
    tags=['project_membership_management', 'project_management_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_project_memberships_for_project(
    project_gid: str,
    user: Optional[str] = None,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Get memberships from a project
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project_gid}/project_statuses',
    description=""" *Deprecated: new integrations should prefer the `/status_updates` route.*

Returns the compact project status update records for all updates on the project. """,
    tags=['status_update_management', 'project_management_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_project_statuses_for_project(
    project_gid: Union[str, str, str, str],
    opt_pretty: Union[
        Optional[bool], Optional[bool], Optional[bool], Optional[bool]
    ] = None,
    opt_fields: Union[
        Optional[OptFields],
        Optional[OptFields],
        Optional[OptFields],
        Optional[OptFields],
    ] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Get statuses from a project
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project_gid}/project_statuses',
    description=""" *Deprecated: new integrations should prefer the `/status_updates` route.*

Creates a new status update on the project.

Returns the full record of the newly created project status update. """,
    tags=['status_update_management', 'project_management_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_project_status_for_project(
    project_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: ProjectsProjectGidProjectStatusesPostRequest = ...,
):
    """
    Create a project status
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project_gid}/removeCustomFieldSetting',
    description=""" Removes a custom field setting from a project. """,
    tags=[
        'custom_field_management',
        'project_management_functions',
        'workspace_operations_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def remove_custom_field_setting_for_project(
    project_gid: str,
    opt_pretty: Optional[bool] = None,
    body: ProjectsProjectGidRemoveCustomFieldSettingPostRequest = ...,
):
    """
    Remove a custom field from a project
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project_gid}/removeFollowers',
    description=""" Removes the specified list of users from following the project, this will not affect project membership status.
Returns the updated project record. """,
    tags=['goal_and_relationship_management', 'project_membership_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def remove_followers_for_project(
    project_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: ProjectsProjectGidRemoveFollowersPostRequest = ...,
):
    """
    Remove followers from a project
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project_gid}/removeMembers',
    description=""" Removes the specified list of users from members of the project.
Returns the updated project record. """,
    tags=[
        'project_membership_management',
        'project_management_functions',
        'user_account_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def remove_members_for_project(
    project_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: ProjectsProjectGidRemoveMembersPostRequest = ...,
):
    """
    Remove users from a project
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project_gid}/saveAsTemplate',
    description=""" Creates and returns a job that will asynchronously handle the project template creation. Note that
while the resulting project template can be accessed with the API, it won't be visible in the Asana
UI until Project Templates 2.0 is launched in the app. See more in [this forum post](https://forum.asana.com/t/a-new-api-for-project-templates/156432). """,
    tags=['project_management_functions', 'workspace_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def project_save_as_template(
    project_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: ProjectsProjectGidSaveAsTemplatePostRequest = ...,
):
    """
    Create a project template from a project
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project_gid}/sections',
    description=""" Returns the compact records for all sections in the specified project. """,
    tags=['project_section_management', 'project_management_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_sections_for_project(
    limit: Optional[int] = None,
    offset: Optional[str] = None,
    project_gid: str = ...,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get sections in a project
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project_gid}/sections',
    description=""" Creates a new section in a project.
Returns the full record of the newly created section. """,
    tags=['project_section_management', 'project_management_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_section_for_project(
    project_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: ProjectsProjectGidSectionsPostRequest = ...,
):
    """
    Create a section in a project
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project_gid}/sections/insert',
    description=""" Move sections relative to each other. One of
`before_section` or `after_section` is required.

Sections cannot be moved between projects.

Returns an empty data block. """,
    tags=['project_section_management', 'project_management_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def insert_section_for_project(
    project_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: ProjectsProjectGidSectionsInsertPostRequest = ...,
):
    """
    Move or Insert sections
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project_gid}/task_counts',
    description=""" Get an object that holds task count fields. **All fields are excluded by default**. You must [opt in](/docs/input-output-options) using `opt_fields` to get any information from this endpoint.

This endpoint has an additional [rate limit](/docs/standard-rate-limits) and each field counts especially high against our [cost limits](/docs/cost-limits).

Milestones are just tasks, so they are included in the `num_tasks`, `num_incomplete_tasks`, and `num_completed_tasks` counts. """,
    tags=['project_management_functions', 'task_management_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_task_counts_for_project(
    project_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Get task count of a project
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project_gid}/tasks',
    description=""" Returns the compact task records for all tasks within the given project, ordered by their priority within the project. Tasks can exist in more than one project at a time. """,
    tags=[
        'project_management_functions',
        'task_management_operations',
        'task_search_functions',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_tasks_for_project(
    completed_since: Optional[str] = None,
    project_gid: str = ...,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Get tasks from a project
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/sections/{section_gid}',
    description=""" A specific, existing section can be deleted by making a DELETE request on
the URL for that section.

Note that sections must be empty to be deleted.

The last remaining section cannot be deleted.

Returns an empty data block. """,
    tags=['project_section_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_section(
    section_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Delete a section
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sections/{section_gid}',
    description=""" Returns the complete record for a single section. """,
    tags=['project_section_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_section(
    section_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get a section
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/sections/{section_gid}',
    description=""" A specific, existing section can be updated by making a PUT request on
the URL for that project. Only the fields provided in the `data` block
will be updated; any unspecified fields will remain unchanged. (note that
at this time, the only field that can be updated is the `name` field.)

When using this method, it is best to specify only those fields you wish
to change, or else you may overwrite changes made by another user since
you last retrieved the task.

Returns the complete updated section record. """,
    tags=['project_section_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_section(
    section_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: SectionsSectionGidPutRequest = ...,
):
    """
    Update a section
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/sections/{section_gid}/addTask',
    description=""" Add a task to a specific, existing section. This will remove the task from other sections of the project.

The task will be inserted at the top of a section unless an insert_before or insert_after parameter is declared.

This does not work for separators (tasks with the resource_subtype of section). """,
    tags=[
        'project_section_management',
        'task_management_operations',
        'task_operations_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def add_task_for_section(
    section_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: SectionsSectionGidAddTaskPostRequest = ...,
):
    """
    Add task to section
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sections/{section_gid}/tasks',
    description=""" *Board view only*: Returns the compact section records for all tasks within the given section. """,
    tags=['project_section_management', 'task_management_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_tasks_for_section(
    section_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Get tasks from a section
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/status_updates',
    description=""" Returns the compact status update records for all updates on the object. """,
    tags=['status_update_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_statuses_for_object(
    parent: str,
    created_since: Optional[datetime] = None,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Get status updates from an object
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/status_updates',
    description=""" Creates a new status update on an object.
Returns the full record of the newly created status update. """,
    tags=['status_update_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_status_for_object(
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
    body: StatusUpdatesPostRequest = ...,
):
    """
    Create a status update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/status_updates/{status_gid}',
    description=""" Deletes a specific, existing status update.

Returns an empty data record. """,
    tags=['status_update_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_status(
    status_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Delete a status update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/status_updates/{status_gid}',
    description=""" Returns the complete record for a single status update. """,
    tags=['status_update_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_status(
    status_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get a status update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/stories/{story_gid}',
    description=""" Deletes a story. A user can only delete stories they have created.

Returns an empty data record. """,
    tags=['story_management_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_story(
    story_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Delete a story
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stories/{story_gid}',
    description=""" Returns the full record for a single story. """,
    tags=['story_management_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_story(
    limit: Optional[int] = None,
    offset: Optional[str] = None,
    story_gid: str = ...,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get a story
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/stories/{story_gid}',
    description=""" Updates the story and returns the full record for the updated story. Only comment stories can have their text updated, and only comment stories and attachment stories can be pinned. Only one of `text` and `html_text` can be specified. """,
    tags=['story_management_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_story(
    story_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: StoriesStoryGidPutRequest = ...,
):
    """
    Update a story
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tags',
    description=""" Returns the compact tag records for some filtered set of tags. Use one or more of the parameters provided to filter the tags returned. """,
    tags=['tag_management_functions', 'workspace_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_tags(
    limit: Optional[int] = None,
    offset: Optional[str] = None,
    workspace: Optional[str] = None,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get multiple tags
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/tags',
    description=""" Creates a new tag in a workspace or organization.

Every tag is required to be created in a specific workspace or
organization, and this cannot be changed once set. Note that you can use
the workspace parameter regardless of whether or not it is an
organization.

Returns the full record of the newly created tag. """,
    tags=['tag_management_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_tag(
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: TagsPostRequest = ...,
):
    """
    Create a tag
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/tags/{tag_gid}',
    description=""" A specific, existing tag can be deleted by making a DELETE request on
the URL for that tag.

Returns an empty data record. """,
    tags=['tag_management_functions', 'custom_field_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_tag(
    tag_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Delete a tag
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tags/{tag_gid}',
    description=""" Returns the complete tag record for a single tag. """,
    tags=['tag_management_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_tag(
    tag_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Get a tag
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/tags/{tag_gid}',
    description=""" Updates the properties of a tag. Only the fields provided in the `data`
block will be updated; any unspecified fields will remain unchanged.

When using this method, it is best to specify only those fields you wish
to change, or else you may overwrite changes made by another user since
you last retrieved the tag.

Returns the complete updated tag record. """,
    tags=['tag_management_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_tag(
    tag_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Update a tag
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tags/{tag_gid}/tasks',
    description=""" Returns the compact task records for all tasks with the given tag. Tasks can have more than one tag at a time. """,
    tags=[
        'task_management_operations',
        'task_search_functions',
        'tag_management_functions',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_tasks_for_tag(
    tag_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Get tasks from a tag
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tasks',
    description=""" Returns the compact task records for some filtered set of tasks. Use one or more of the parameters provided to filter the tasks returned. You must specify a `project` or `tag` if you do not specify `assignee` and `workspace`.

For more complex task retrieval, use [workspaces/{workspace_gid}/tasks/search](/docs/search-tasks-in-a-workspace). """,
    tags=['task_management_operations', 'task_search_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_tasks(
    limit: Optional[int] = None,
    offset: Optional[str] = None,
    assignee: Optional[str] = None,
    project: Optional[str] = None,
    section: Optional[str] = None,
    workspace: Optional[str] = None,
    completed_since: Optional[datetime] = None,
    modified_since: Optional[datetime] = None,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get multiple tasks
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/tasks',
    description=""" Creating a new task is as easy as POSTing to the `/tasks` endpoint with a
data block containing the fields you’d like to set on the task. Any
unspecified fields will take on default values.

Every task is required to be created in a specific workspace, and this
workspace cannot be changed once set. The workspace need not be set
explicitly if you specify `projects` or a `parent` task instead. """,
    tags=['task_management_operations', 'task_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_task(
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: TasksPostRequest = ...,
):
    """
    Create a task
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/tasks/{task_gid}',
    description=""" A specific, existing task can be deleted by making a DELETE request on
the URL for that task. Deleted tasks go into the “trash” of the user
making the delete request. Tasks can be recovered from the trash within a
period of 30 days; afterward they are completely removed from the system.

Returns an empty data record. """,
    tags=['task_management_operations', 'task_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_task(
    task_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Delete a task
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tasks/{task_gid}',
    description=""" Returns the complete task record for a single task. """,
    tags=['task_management_operations', 'task_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_task(
    task_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get a task
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/tasks/{task_gid}',
    description=""" A specific, existing task can be updated by making a PUT request on the
URL for that task. Only the fields provided in the `data` block will be
updated; any unspecified fields will remain unchanged.

When using this method, it is best to specify only those fields you wish
to change, or else you may overwrite changes made by another user since
you last retrieved the task.

Returns the complete updated task record. """,
    tags=['task_management_operations', 'task_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_task(
    task_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: TasksTaskGidPutRequest = ...,
):
    """
    Update a task
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/tasks/{task_gid}/addDependencies',
    description=""" Marks a set of tasks as dependencies of this task, if they are not already dependencies. *A task can have at most 30 dependents and dependencies combined*. """,
    tags=['task_management_operations', 'task_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def add_dependencies_for_task(
    task_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: TasksTaskGidAddDependenciesPostRequest = ...,
):
    """
    Set dependencies for a task
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/tasks/{task_gid}/addDependents',
    description=""" Marks a set of tasks as dependents of this task, if they are not already dependents. *A task can have at most 30 dependents and dependencies combined*. """,
    tags=['task_management_operations', 'task_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def add_dependents_for_task(
    task_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: TasksTaskGidAddDependentsPostRequest = ...,
):
    """
    Set dependents for a task
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/tasks/{task_gid}/addFollowers',
    description=""" Adds followers to a task. Returns an empty data block.
Each task can be associated with zero or more followers in the system.
Requests to add/remove followers, if successful, will return the complete updated task record, described above. """,
    tags=[
        'goal_and_relationship_management',
        'project_membership_management',
        'task_management_operations',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def add_followers_for_task(
    task_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: TasksTaskGidAddFollowersPostRequest = ...,
):
    """
    Add followers to a task
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/tasks/{task_gid}/addProject',
    description=""" Adds the task to the specified project, in the optional location
specified. If no location arguments are given, the task will be added to
the end of the project.

`addProject` can also be used to reorder a task within a project or
section that already contains it.

At most one of `insert_before`, `insert_after`, or `section` should be
specified. Inserting into a section in an non-order-dependent way can be
done by specifying section, otherwise, to insert within a section in a
particular place, specify `insert_before` or `insert_after` and a task
within the section to anchor the position of this task.

Returns an empty data block. """,
    tags=[
        'project_management_functions',
        'task_management_operations',
        'project_section_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def add_project_for_task(
    task_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: TasksTaskGidAddProjectPostRequest = ...,
):
    """
    Add a project to a task
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/tasks/{task_gid}/addTag',
    description=""" Adds a tag to a task. Returns an empty data block. """,
    tags=[
        'tag_management_functions',
        'task_management_operations',
        'task_operations_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def add_tag_for_task(
    task_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: TasksTaskGidAddTagPostRequest = ...,
):
    """
    Add a tag to a task
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tasks/{task_gid}/dependencies',
    description=""" Returns the compact representations of all of the dependencies of a task. """,
    tags=['task_management_operations', 'task_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_dependencies_for_task(
    task_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Get dependencies from a task
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tasks/{task_gid}/dependents',
    description=""" Returns the compact representations of all of the dependents of a task. """,
    tags=['task_management_operations', 'task_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_dependents_for_task(
    task_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Get dependents from a task
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/tasks/{task_gid}/duplicate',
    description=""" Creates and returns a job that will asynchronously handle the duplication. """,
    tags=['task_management_operations', 'task_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def duplicate_task(
    task_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: TasksTaskGidDuplicatePostRequest = ...,
):
    """
    Duplicate a task
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tasks/{task_gid}/projects',
    description=""" Returns a compact representation of all of the projects the task is in. """,
    tags=[
        'project_management_functions',
        'task_management_operations',
        'task_operations_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_projects_for_task(
    task_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Get projects a task is in
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/tasks/{task_gid}/removeDependencies',
    description=""" Unlinks a set of dependencies from this task. """,
    tags=['task_management_operations', 'task_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def remove_dependencies_for_task(
    task_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: TasksTaskGidRemoveDependenciesPostRequest = ...,
):
    """
    Unlink dependencies from a task
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/tasks/{task_gid}/removeDependents',
    description=""" Unlinks a set of dependents from this task. """,
    tags=['task_management_operations', 'task_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def remove_dependents_for_task(
    task_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: TasksTaskGidRemoveDependentsPostRequest = ...,
):
    """
    Unlink dependents from a task
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/tasks/{task_gid}/removeFollowers',
    description=""" Removes each of the specified followers from the task if they are following. Returns the complete, updated record for the affected task. """,
    tags=[
        'goal_and_relationship_management',
        'project_membership_management',
        'task_management_operations',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def remove_follower_for_task(
    task_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: TasksTaskGidRemoveFollowersPostRequest = ...,
):
    """
    Remove followers from a task
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/tasks/{task_gid}/removeProject',
    description=""" Removes the task from the specified project. The task will still exist in
the system, but it will not be in the project anymore.

Returns an empty data block. """,
    tags=['task_management_operations', 'task_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def remove_project_for_task(
    task_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: TasksTaskGidRemoveProjectPostRequest = ...,
):
    """
    Remove a project from a task
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/tasks/{task_gid}/removeTag',
    description=""" Removes a tag from a task. Returns an empty data block. """,
    tags=['task_management_operations', 'tag_management_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def remove_tag_for_task(
    task_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: TasksTaskGidRemoveTagPostRequest = ...,
):
    """
    Remove a tag from a task
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/tasks/{task_gid}/setParent',
    description=""" parent, or no parent task at all. Returns an empty data block. When using `insert_before` and `insert_after`, at most one of those two options can be specified, and they must already be subtasks of the parent. """,
    tags=['task_management_operations', 'task_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def set_parent_for_task(
    task_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: TasksTaskGidSetParentPostRequest = ...,
):
    """
    Set the parent of a task
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tasks/{task_gid}/stories',
    description=""" Returns the compact records for all stories on the task. """,
    tags=['story_management_functions', 'task_management_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_stories_for_task(
    limit: Optional[int] = None,
    offset: Optional[str] = None,
    task_gid: str = ...,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get stories from a task
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/tasks/{task_gid}/stories',
    description=""" Adds a story to a task. This endpoint currently only allows for comment
stories to be created. The comment will be authored by the currently
authenticated user, and timestamped when the server receives the request.

Returns the full record for the new story added to the task. """,
    tags=[
        'story_management_functions',
        'task_management_operations',
        'task_operations_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_story_for_task(
    task_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: TasksTaskGidStoriesPostRequest = ...,
):
    """
    Create a story on a task
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tasks/{task_gid}/subtasks',
    description=""" Returns a compact representation of all of the subtasks of a task. """,
    tags=['task_management_operations', 'task_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_subtasks_for_task(
    limit: Optional[int] = None,
    offset: Optional[str] = None,
    task_gid: str = ...,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get subtasks from a task
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/tasks/{task_gid}/subtasks',
    description=""" Creates a new subtask and adds it to the parent task. Returns the full record for the newly created subtask. """,
    tags=['task_management_operations', 'task_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_subtask_for_task(
    task_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: TasksTaskGidSubtasksPostRequest = ...,
):
    """
    Create a subtask
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tasks/{task_gid}/tags',
    description=""" Get a compact representation of all of the tags the task has. """,
    tags=['tag_management_functions', 'task_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_tags_for_task(
    task_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Get a task's tags
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/team_memberships',
    description=""" Returns compact team membership records. """,
    tags=['team_information_management', 'workspace_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_team_memberships(
    team: Optional[str] = None,
    user: Optional[str] = None,
    workspace: Optional[str] = None,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Get team memberships
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/team_memberships/{team_membership_gid}',
    description=""" Returns the complete team membership record for a single team membership. """,
    tags=['team_information_management', 'workspace_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_team_membership(
    team_membership_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get a team membership
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/teams',
    description=""" Creates a team within the current workspace. """,
    tags=['team_information_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_team(
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
    body: TeamsPostRequest = ...,
):
    """
    Create a team
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/teams',
    description=""" Updates a team within the current workspace. """,
    tags=['team_information_management', 'workspace_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_team(
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
    body: TeamsPutRequest = ...,
):
    """
    Update a team
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/teams/{team_gid}',
    description=""" Returns the full record for a single team. """,
    tags=['team_information_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_team(
    team_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Get a team
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/teams/{team_gid}/addUser',
    description=""" The user making this call must be a member of the team in order to add others. The user being added must exist in the same organization as the team.

Returns the complete team membership record for the newly added user. """,
    tags=['team_information_management', 'user_account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def add_user_for_team(
    team_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: TeamsTeamGidAddUserPostRequest = ...,
):
    """
    Add a user to a team
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/teams/{team_gid}/project_templates',
    description=""" Returns the compact project template records for all project templates in the team. """,
    tags=['project_management_functions', 'team_information_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_project_templates_for_team(
    limit: Optional[int] = None,
    offset: Optional[str] = None,
    team_gid: str = ...,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get a team's project templates
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/teams/{team_gid}/projects',
    description=""" Returns the compact project records for all projects in the team. """,
    tags=[
        'project_management_functions',
        'team_information_management',
        'workspace_operations_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_projects_for_team(
    limit: Optional[int] = None,
    offset: Optional[str] = None,
    archived: Optional[bool] = None,
    team_gid: str = ...,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get a team's projects
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/teams/{team_gid}/projects',
    description=""" Creates a project shared with the given team.

Returns the full record of the newly created project. """,
    tags=['project_management_functions', 'team_information_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_project_for_team(
    team_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: TeamsTeamGidProjectsPostRequest = ...,
):
    """
    Create a project in a team
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/teams/{team_gid}/removeUser',
    description=""" The user making this call must be a member of the team in order to remove themselves or others. """,
    tags=[
        'project_membership_management',
        'user_account_management',
        'team_information_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def remove_user_for_team(
    team_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: TeamsTeamGidRemoveUserPostRequest = ...,
):
    """
    Remove a user from a team
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/teams/{team_gid}/team_memberships',
    description=""" Returns the compact team memberships for the team. """,
    tags=[
        'team_information_management',
        'project_membership_management',
        'workspace_operations_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_team_memberships_for_team(
    team_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Get memberships from a team
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/teams/{team_gid}/users',
    description=""" Returns the compact records for all users that are members of the team.
Results are sorted alphabetically and limited to 2000. For more results use the `/users` endpoint. """,
    tags=['team_information_management', 'user_account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_users_for_team(
    team_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    offset: Optional[str] = None,
):
    """
    Get users in a team
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/time_periods',
    description=""" Returns compact time period records. """,
    tags=['time_period_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_time_periods(
    start_on: Optional[date_aliased] = None,
    end_on: Optional[date_aliased] = None,
    workspace: str = ...,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Get time periods
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/time_periods/{time_period_gid}',
    description=""" Returns the full record for a single time period. """,
    tags=['time_period_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_time_period(
    time_period_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get a time period
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/user_task_lists/{user_task_list_gid}',
    description=""" Returns the full record for a user task list. """,
    tags=['task_management_operations', 'task_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_user_task_list(
    user_task_list_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get a user task list
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/user_task_lists/{user_task_list_gid}/tasks',
    description=""" Returns the compact list of tasks in a user’s My Tasks list.
*Note: Access control is enforced for this endpoint as with all Asana API endpoints, meaning a user’s private tasks will be filtered out if the API-authenticated user does not have access to them.*
*Note: Both complete and incomplete tasks are returned by default unless they are filtered out (for example, setting `completed_since=now` will return only incomplete tasks, which is the default view for “My Tasks” in Asana.)* """,
    tags=['task_management_operations', 'task_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_tasks_for_user_task_list(
    completed_since: Optional[str] = None,
    user_task_list_gid: str = ...,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Get tasks from a user task list
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users',
    description=""" Returns the user records for all users in all workspaces and organizations accessible to the authenticated user. Accepts an optional workspace ID parameter.
Results are sorted by user ID. """,
    tags=['user_account_management', 'team_information_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_users(
    workspace: Optional[str] = None,
    team: Optional[str] = None,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Get multiple users
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users/{user_gid}',
    description=""" Returns the full user record for the single user with the provided ID. """,
    tags=['user_account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_user(
    user_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get a user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users/{user_gid}/favorites',
    description=""" Returns all of a user's favorites in the given workspace, of the given type.
Results are given in order (The same order as Asana's sidebar). """,
    tags=['user_account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_favorites_for_user(
    user_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    resource_type: ResourceType = 'project',
    workspace: str = ...,
):
    """
    Get a user's favorites
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users/{user_gid}/team_memberships',
    description=""" Returns the compact team membership records for the user. """,
    tags=['user_account_management', 'workspace_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_team_memberships_for_user(
    workspace: str,
    user_gid: str = ...,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Get memberships from a user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users/{user_gid}/teams',
    description=""" Returns the compact records for all teams to which the given user is assigned. """,
    tags=['team_information_management', 'user_account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_teams_for_user(
    user_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
    organization: str = ...,
):
    """
    Get teams for a user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users/{user_gid}/user_task_list',
    description=""" Returns the full record for a user's task list. """,
    tags=['task_operations_management', 'task_management_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_user_task_list_for_user(
    user_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    workspace: str = ...,
):
    """
    Get a user's task list
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users/{user_gid}/workspace_memberships',
    description=""" Returns the compact workspace membership records for the user. """,
    tags=['workspace_operations_management', 'user_account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_workspace_memberships_for_user(
    user_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Get workspace memberships for a user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/webhooks',
    description=""" Get the compact representation of all webhooks your app has registered for the authenticated user in the given workspace. """,
    tags=['webhook_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_webhooks(
    limit: Optional[int] = None,
    offset: Optional[str] = None,
    workspace: str = ...,
    resource: Optional[str] = None,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get multiple webhooks
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/webhooks',
    description=""" Establishing a webhook is a two-part process. First, a simple HTTP POST
request initiates the creation similar to creating any other resource.

Next, in the middle of this request comes the confirmation handshake.
When a webhook is created, we will send a test POST to the target with an
`X-Hook-Secret` header. The target must respond with a `200 OK` or `204
No Content` and a matching `X-Hook-Secret` header to confirm that this
webhook subscription is indeed expected. We strongly recommend storing
this secret to be used to verify future webhook event signatures.

The POST request to create the webhook will then return with the status
of the request. If you do not acknowledge the webhook’s confirmation
handshake it will fail to setup, and you will receive an error in
response to your attempt to create it. This means you need to be able to
receive and complete the webhook *while* the POST request is in-flight
(in other words, have a server that can handle requests asynchronously).

Invalid hostnames like localhost will recieve a 403 Forbidden status code.

```
# Request
curl -H "Authorization: Bearer <personal_access_token>" \
-X POST https://app.asana.com/api/1.0/webhooks \
-d "resource=8675309" \
-d "target=https://example.com/receive-webhook/7654"
```

```
# Handshake sent to https://example.com/
POST /receive-webhook/7654
X-Hook-Secret: b537207f20cbfa02357cf448134da559e8bd39d61597dcd5631b8012eae53e81
```

```
# Handshake response sent by example.com
HTTP/1.1 200
X-Hook-Secret: b537207f20cbfa02357cf448134da559e8bd39d61597dcd5631b8012eae53e81
```

```
# Response
HTTP/1.1 201
{
  "data": {
    "gid": "43214",
    "resource": {
      "gid": "8675309",
      "name": "Bugs"
    },
    "target": "https://example.com/receive-webhook/7654",
    "active": false,
    "last_success_at": null,
    "last_failure_at": null,
    "last_failure_content": null
  }
}
``` """,
    tags=['webhook_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_webhook(
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: WebhooksPostRequest = ...,
):
    """
    Establish a webhook
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/webhooks/{webhook_gid}',
    description=""" This method *permanently* removes a webhook. Note that it may be possible to receive a request that was already in flight after deleting the webhook, but no further requests will be issued. """,
    tags=['webhook_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_webhook(
    webhook_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Delete a webhook
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/webhooks/{webhook_gid}',
    description=""" Returns the full record for the given webhook. """,
    tags=['webhook_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_webhook(
    webhook_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get a webhook
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/webhooks/{webhook_gid}',
    description=""" An existing webhook's filters can be updated by making a PUT request on the URL for that webhook. Note that the webhook's previous `filters` array will be completely overwritten by the `filters` sent in the PUT request. """,
    tags=['webhook_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_webhook(
    webhook_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: WebhooksWebhookGidPutRequest = ...,
):
    """
    Update a webhook
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/workspace_memberships/{workspace_membership_gid}',
    description=""" Returns the complete workspace record for a single workspace membership. """,
    tags=['workspace_operations_management', 'user_account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_workspace_membership(
    workspace_membership_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get a workspace membership
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/workspaces',
    description=""" Returns the compact records for all workspaces visible to the authorized user. """,
    tags=['workspace_operations_management', 'project_management_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_workspaces(
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Get multiple workspaces
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/workspaces/{workspace_gid}',
    description=""" Returns the full workspace record for a single workspace. """,
    tags=['workspace_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_workspace(
    workspace_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get a workspace
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/workspaces/{workspace_gid}',
    description=""" A specific, existing workspace can be updated by making a PUT request on the URL for that workspace. Only the fields provided in the data block will be updated; any unspecified fields will remain unchanged.
Currently the only field that can be modified for a workspace is its name.
Returns the complete, updated workspace record. """,
    tags=[
        'workspace_operations_management',
        'project_management_functions',
        'workspace_custom_field_functions',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_workspace(
    workspace_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: WorkspacesWorkspaceGidPutRequest = ...,
):
    """
    Update a workspace
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/workspaces/{workspace_gid}/addUser',
    description=""" Add a user to a workspace or organization.
The user can be referenced by their globally unique user ID or their email address. Returns the full user record for the invited user. """,
    tags=['user_account_management', 'workspace_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def add_user_for_workspace(
    workspace_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: WorkspacesWorkspaceGidAddUserPostRequest = ...,
):
    """
    Add a user to a workspace or organization
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/workspaces/{workspace_gid}/audit_log_events',
    description=""" Retrieve the audit log events that have been captured in your domain.

This endpoint will return a list of [AuditLogEvent](/docs/audit-log-event) objects, sorted by creation time in ascending order. Note that the Audit Log API captures events from October 8th, 2021 and later. Queries for events before this date will not return results.

There are a number of query parameters (below) that can be used to filter the set of [AuditLogEvent](/docs/audit-log-event) objects that are returned in the response. Any combination of query parameters is valid. When no filters are provided, all of the events that have been captured in your domain will match.

The list of events will always be [paginated](/docs/pagination). The default limit is 1000 events. The next set of events can be retrieved using the `offset` from the previous response. If there are no events that match the provided filters in your domain, the endpoint will return `null` for the `next_page` field. Querying again with the same filters may return new events if they were captured after the last request. Once a response includes a `next_page` with an `offset`, subsequent requests can be made with the latest `offset` to poll for new events that match the provided filters.

When no `offset` is provided, the response will begin with the oldest events that match the provided filters. It is important to note that [AuditLogEvent](/docs/audit-log-event) objects will be permanently deleted from our systems after 90 days. If you wish to keep a permanent record of these events, we recommend using a SIEM tool to ingest and store these logs. """,
    tags=['audit_logging_management', 'event_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_audit_log_events(
    workspace_gid: str,
    start_at: Optional[datetime] = None,
    end_at: Optional[datetime] = None,
    event_type: Optional[str] = None,
    actor_type: Optional[ActorType] = None,
    actor_gid: Optional[str] = None,
    resource_gid: Optional[str] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Get audit log events
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/workspaces/{workspace_gid}/custom_fields',
    description=""" Returns a list of the compact representation of all of the custom fields in a workspace. """,
    tags=['custom_field_management', 'workspace_custom_field_functions'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_custom_fields_for_workspace(
    workspace_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Get a workspace's custom fields
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/workspaces/{workspace_gid}/projects',
    description=""" Returns the compact project records for all projects in the workspace.
*Note: This endpoint may timeout for large domains. Prefer the `/teams/{team_gid}/projects` endpoint.* """,
    tags=['project_management_functions', 'workspace_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_projects_for_workspace(
    limit: Optional[int] = None,
    offset: Optional[str] = None,
    archived: Optional[bool] = None,
    workspace_gid: str = ...,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get all projects in a workspace
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/workspaces/{workspace_gid}/projects',
    description=""" Returns the compact project records for all projects in the workspace.

If the workspace for your project is an organization, you must also
supply a team to share the project with.

Returns the full record of the newly created project. """,
    tags=['project_management_functions', 'workspace_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_project_for_workspace(
    workspace_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: WorkspacesWorkspaceGidProjectsPostRequest = ...,
):
    """
    Create a project in a workspace
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/workspaces/{workspace_gid}/removeUser',
    description=""" Remove a user from a workspace or organization.
The user making this call must be an admin in the workspace. The user can be referenced by their globally unique user ID or their email address.
Returns an empty data record. """,
    tags=['user_account_management', 'workspace_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def remove_user_for_workspace(
    workspace_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: WorkspacesWorkspaceGidRemoveUserPostRequest = ...,
):
    """
    Remove a user from a workspace or organization
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/workspaces/{workspace_gid}/tags',
    description=""" Returns the compact tag records for some filtered set of tags. Use one or more of the parameters provided to filter the tags returned. """,
    tags=['tag_management_functions', 'workspace_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_tags_for_workspace(
    limit: Optional[int] = None,
    offset: Optional[str] = None,
    workspace_gid: str = ...,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get tags in a workspace
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/workspaces/{workspace_gid}/tags',
    description=""" Creates a new tag in a workspace or organization.

Every tag is required to be created in a specific workspace or
organization, and this cannot be changed once set. Note that you can use
the workspace parameter regardless of whether or not it is an
organization.

Returns the full record of the newly created tag. """,
    tags=['tag_management_functions', 'workspace_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_tag_for_workspace(
    workspace_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    body: WorkspacesWorkspaceGidTagsPostRequest = ...,
):
    """
    Create a tag in a workspace
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/workspaces/{workspace_gid}/tasks/search',
    description=""" To mirror the functionality of the Asana web app's advanced search feature, the Asana API has a task search endpoint that allows you to build complex filters to find and retrieve the exact data you need.
#### Premium access
Like the Asana web product's advance search feature, this search endpoint will only be available to premium Asana users. A user is premium if any of the following is true:

- The workspace in which the search is being performed is a premium workspace - The user is a member of a premium team inside the workspace

Even if a user is only a member of a premium team inside a non-premium workspace, search will allow them to find data anywhere in the workspace, not just inside the premium team. Making a search request using credentials of a non-premium user will result in a `402 Payment Required` error.
#### Pagination
Search results are not stable; repeating the same query multiple times may return the data in a different order, even if the data do not change. Because of this, the traditional [pagination](https://developers.asana.com/docs/#pagination) available elsewhere in the Asana API is not available here. However, you can paginate manually by sorting the search results by their creation time and then modifying each subsequent query to exclude data you have already seen. Page sizes are limited to a maximum of 100 items, and can be specified by the `limit` query parameter.
#### Eventual consistency
Changes in Asana (regardless of whether they’re made though the web product or the API) are forwarded to our search infrastructure to be indexed. This process can take between 10 and 60 seconds to complete under normal operation, and longer during some production incidents. Making a change to a task that would alter its presence in a particular search query will not be reflected immediately. This is also true of the advanced search feature in the web product.
#### Rate limits
You may receive a `429 Too Many Requests` response if you hit any of our [rate limits](https://developers.asana.com/docs/#rate-limits).
#### Custom field parameters
| Parameter name | Custom field type | Accepted type |
|---|---|---|
| custom_fields.{gid}.is_set | All | Boolean |
| custom_fields.{gid}.value | Text | String |
| custom_fields.{gid}.value | Number | Number |
| custom_fields.{gid}.value | Enum | Enum option ID |
| custom_fields.{gid}.starts_with | Text only | String |
| custom_fields.{gid}.ends_with | Text only | String |
| custom_fields.{gid}.contains | Text only | String |
| custom_fields.{gid}.less_than | Number only | Number |
| custom_fields.{gid}.greater_than | Number only | Number |


For example, if the gid of the custom field is 12345, these query parameter to find tasks where it is set would be `custom_fields.12345.is_set=true`. To match an exact value for an enum custom field, use the gid of the desired enum option and not the name of the enum option: `custom_fields.12345.value=67890`.

**Not Supported**: searching for multiple exact matches of a custom field, searching for multi-enum custom field

*Note: If you specify `projects.any` and `sections.any`, you will receive tasks for the project **and** tasks for the section. If you're looking for only tasks in a section, omit the `projects.any` from the request.* """,
    tags=[
        'task_search_functions',
        'task_management_operations',
        'workspace_operations_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def search_tasks_for_workspace(
    workspace_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    text: Optional[str] = None,
    resource_subtype: Optional[ResourceSubtype6] = 'milestone',
    assignee_any: Optional[str] = Query(None, alias='assignee.any'),
    assignee_not: Optional[str] = Query(None, alias='assignee.not'),
    portfolios_any: Optional[str] = Query(None, alias='portfolios.any'),
    projects_any: Optional[str] = Query(None, alias='projects.any'),
    projects_not: Optional[str] = Query(None, alias='projects.not'),
    projects_all: Optional[str] = Query(None, alias='projects.all'),
    sections_any: Optional[str] = Query(None, alias='sections.any'),
    sections_not: Optional[str] = Query(None, alias='sections.not'),
    sections_all: Optional[str] = Query(None, alias='sections.all'),
    tags_any: Optional[str] = Query(None, alias='tags.any'),
    tags_not: Optional[str] = Query(None, alias='tags.not'),
    tags_all: Optional[str] = Query(None, alias='tags.all'),
    teams_any: Optional[str] = Query(None, alias='teams.any'),
    followers_not: Optional[str] = Query(None, alias='followers.not'),
    created_by_any: Optional[str] = Query(None, alias='created_by.any'),
    created_by_not: Optional[str] = Query(None, alias='created_by.not'),
    assigned_by_any: Optional[str] = Query(None, alias='assigned_by.any'),
    assigned_by_not: Optional[str] = Query(None, alias='assigned_by.not'),
    liked_by_not: Optional[str] = Query(None, alias='liked_by.not'),
    commented_on_by_not: Optional[str] = Query(None, alias='commented_on_by.not'),
    due_on_before: Optional[date_aliased] = Query(None, alias='due_on.before'),
    due_on_after: Optional[date_aliased] = Query(None, alias='due_on.after'),
    due_on: Optional[date_aliased] = None,
    due_at_before: Optional[datetime] = Query(None, alias='due_at.before'),
    due_at_after: Optional[datetime] = Query(None, alias='due_at.after'),
    start_on_before: Optional[date_aliased] = Query(None, alias='start_on.before'),
    start_on_after: Optional[date_aliased] = Query(None, alias='start_on.after'),
    start_on: Optional[date_aliased] = None,
    created_on_before: Optional[date_aliased] = Query(None, alias='created_on.before'),
    created_on_after: Optional[date_aliased] = Query(None, alias='created_on.after'),
    created_on: Optional[date_aliased] = None,
    created_at_before: Optional[datetime] = Query(None, alias='created_at.before'),
    created_at_after: Optional[datetime] = Query(None, alias='created_at.after'),
    completed_on_before: Optional[date_aliased] = Query(
        None, alias='completed_on.before'
    ),
    completed_on_after: Optional[date_aliased] = Query(
        None, alias='completed_on.after'
    ),
    completed_on: Optional[date_aliased] = None,
    completed_at_before: Optional[datetime] = Query(None, alias='completed_at.before'),
    completed_at_after: Optional[datetime] = Query(None, alias='completed_at.after'),
    modified_on_before: Optional[date_aliased] = Query(
        None, alias='modified_on.before'
    ),
    modified_on_after: Optional[date_aliased] = Query(None, alias='modified_on.after'),
    modified_on: Optional[date_aliased] = None,
    modified_at_before: Optional[datetime] = Query(None, alias='modified_at.before'),
    modified_at_after: Optional[datetime] = Query(None, alias='modified_at.after'),
    is_blocking: Optional[bool] = None,
    is_blocked: Optional[bool] = None,
    has_attachment: Optional[bool] = None,
    completed: Optional[bool] = None,
    is_subtask: Optional[bool] = None,
    sort_by: Optional[SortBy] = 'modified_at',
    sort_ascending: Optional[bool] = False,
):
    """
    Search tasks in a workspace
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/workspaces/{workspace_gid}/teams',
    description=""" Returns the compact records for all teams in the workspace visible to the authorized user. """,
    tags=['team_information_management', 'workspace_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_teams_for_workspace(
    workspace_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Get teams in a workspace
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/workspaces/{workspace_gid}/typeahead',
    description=""" Retrieves objects in the workspace based via an auto-completion/typeahead
search algorithm. This feature is meant to provide results quickly, so do
not rely on this API to provide extremely accurate search results. The
result set is limited to a single page of results with a maximum size, so
you won’t be able to fetch large numbers of results.

The typeahead search API provides search for objects from a single
workspace. This endpoint should be used to query for objects when
creating an auto-completion/typeahead search feature. This API is meant
to provide results quickly and should not be relied upon for accurate or
exhaustive search results. The results sets are limited in size and
cannot be paginated.

Queries return a compact representation of each object which is typically
the gid and name fields. Interested in a specific set of fields or all of
the fields?! Of course you are. Use field selectors to manipulate what
data is included in a response.

Resources with type `user` are returned in order of most contacted to
least contacted. This is determined by task assignments, adding the user
to projects, and adding the user as a follower to tasks, messages,
etc.

Resources with type `project` are returned in order of recency. This is
determined when the user visits the project, is added to the project, and
completes tasks in the project.

Resources with type `task` are returned with priority placed on tasks
the user is following, but no guarantee on the order of those tasks.

Resources with type `project_template` are returned with priority
placed on favorited project templates.

Leaving the `query` string empty or omitted will give you results, still
following the resource ordering above. This could be used to list users or
projects that are relevant for the requesting user's api token. """,
    tags=['user_account_management', 'workspace_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def typeahead_for_workspace(
    workspace_gid: str,
    resource_type: ResourceType2 = 'user',
    type: Optional[Type2] = 'user',
    query: Optional[str] = None,
    count: Optional[int] = None,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
):
    """
    Get objects via typeahead
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/workspaces/{workspace_gid}/users',
    description=""" Returns the compact records for all users in the specified workspace or organization.
Results are sorted alphabetically and limited to 2000. For more results use the `/users` endpoint. """,
    tags=['user_account_management', 'workspace_operations_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_users_for_workspace(
    workspace_gid: str,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    offset: Optional[str] = None,
):
    """
    Get users in a workspace or organization
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/workspaces/{workspace_gid}/workspace_memberships',
    description=""" Returns the compact workspace membership records for the workspace. """,
    tags=[
        'user_account_management',
        'workspace_operations_management',
        'team_information_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_workspace_memberships_for_workspace(
    workspace_gid: str,
    user: Optional[str] = None,
    opt_pretty: Optional[bool] = None,
    opt_fields: Optional[OptFields] = None,
    limit: Optional[int] = None,
    offset: Optional[str] = None,
):
    """
    Get the workspace memberships for a workspace
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


def _load_local_settings() -> None:
    """Load project-local settings for environment configuration."""
    settings_hint = os.environ.get("MCP_LOCAL_SETTINGS")

    candidate_paths: list[Path] = []
    if settings_hint:
        candidate_paths.append(Path(settings_hint))

    module_dir = Path(__file__).resolve().parent
    candidate_paths.append(module_dir / "local_settings.json")
    candidate_paths.append(module_dir.parent / "local_settings.json")

    for candidate in candidate_paths:
        try:
            candidate = candidate.expanduser().resolve()
        except (FileNotFoundError, RuntimeError, AttributeError):
            continue
        if not candidate.exists():
            continue
        try:
            raw_content = candidate.read_text(encoding="utf-8")
            data = json.loads(raw_content)
        except Exception:
            continue

        for key, value in data.get("env", {}).items():
            if key not in os.environ:
                os.environ[key] = str(value)

        if "config_path" in data and "CONFIG_PATH" not in os.environ:
            config_path = Path(str(data["config_path"]))
            if not config_path.is_absolute():
                config_path = (candidate.parent / config_path).resolve()
            os.environ["CONFIG_PATH"] = str(config_path)

        if "config" in data and "CONFIG" not in os.environ:
            config_value = data["config"]
            if isinstance(config_value, str):
                os.environ["CONFIG"] = config_value
            else:
                os.environ["CONFIG"] = json.dumps(config_value)

        if "mcp_settings" in data and "MCP_SETTINGS" not in os.environ:
            os.environ["MCP_SETTINGS"] = json.dumps(data["mcp_settings"])

        if "security" in data and "SECURITY" not in os.environ:
            os.environ["SECURITY"] = json.dumps(data["security"])

        if "security_path" in data and "SECURITY" not in os.environ:
            security_path = Path(str(data["security_path"]))
            if not security_path.is_absolute():
                security_path = (candidate.parent / security_path).resolve()
            os.environ["SECURITY"] = security_path.read_text(encoding="utf-8").strip()

        break

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    _load_local_settings()

    if "SECURITY" not in os.environ:
        token = os.environ.get("ASANA_PAT") or os.environ.get("ASANA_TOKEN")
        if token:
            os.environ["SECURITY"] = json.dumps({
                "type": "http",
                "schema_parameters": {"scheme": "bearer"},
                "value": token.strip(),
            })

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_raw = os.environ["SECURITY"]
        if security_raw:
            stripped = security_raw.strip()
            ensure_json = False
            if not stripped.startswith("{"):
                ensure_json = True
            else:
                try:
                    json.loads(stripped)
                except json.JSONDecodeError:
                    ensure_json = True
            if ensure_json:
                os.environ["SECURITY"] = json.dumps({
                    "type": "http",
                    "schema_parameters": {"scheme": "bearer"},
                    "value": stripped,
                })

        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings: dict[str, Any] = {}
    mcp_settings_raw = os.environ.get("MCP_SETTINGS")
    if mcp_settings_raw:
        try:
            parsed_settings = json.loads(mcp_settings_raw)
        except json.JSONDecodeError:
            parsed_settings = None
        if isinstance(parsed_settings, dict):
            mcp_settings.update(parsed_settings)

    host_override = os.environ.get("MCP_HOST")
    if host_override:
        mcp_settings["host"] = host_override

    port_override = os.environ.get("MCP_PORT")
    if port_override:
        try:
            mcp_settings["port"] = int(port_override)
        except (TypeError, ValueError):
            pass

    api_key = os.environ.get("MCP_API_KEY")
    if api_key:
        header_name = os.environ.get("MCP_API_KEY_HEADER", "x-mcp-api-key")
        exempt_raw = os.environ.get("MCP_API_KEY_EXEMPT", "")
        exempt_paths = {path.strip() for path in exempt_raw.split(",") if path.strip()}
        app.add_middleware(
            APIKeyMiddleware,
            api_key=api_key.strip(),
            header_name=(header_name or "x-mcp-api-key").strip().lower(),
            exempt_paths=exempt_paths or None,
        )

    app.get_mcp(**mcp_settings).run(transport=args.transport)
